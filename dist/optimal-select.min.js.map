{"version":3,"file":"optimal-select.min.js","mappings":"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","sources":["webpack://OptimalSelect/webpack/universalModuleDefinition","webpack://OptimalSelect/webpack/bootstrap","webpack://OptimalSelect/webpack/runtime/define property getters","webpack://OptimalSelect/webpack/runtime/global","webpack://OptimalSelect/webpack/runtime/hasOwnProperty shorthand","webpack://OptimalSelect/./src/adapt.js","webpack://OptimalSelect/./src/utilities.js","webpack://OptimalSelect/./src/match.js","webpack://OptimalSelect/./src/optimize.js","webpack://OptimalSelect/./src/common.js","webpack://OptimalSelect/./src/select.js","webpack://OptimalSelect/./src/index.mjs"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"OptimalSelect\"] = factory();\n\telse\n\t\troot[\"OptimalSelect\"] = factory();\n})(this, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\n * # Adapt\n *\n * Check and extend the environment for universal usage.\n */\n\n/**\n * Modify the context based on the environment\n *\n * @param  {HTMLELement} element - [description]\n * @param  {Object}      options - [description]\n * @return {boolean}             - [description]\n */\nexport default function adapt (element, options) {\n\n  // detect environment setup\n  if (global.document) {\n    return false\n  } else {\n    global.document = options.context || (() => {\n      var root = element\n      while (root.parent) {\n        root = root.parent\n      }\n      return root\n    })()\n  }\n\n  // https://github.com/fb55/domhandler/blob/master/index.js#L75\n  const ElementPrototype = Object.getPrototypeOf(global.document)\n\n  // alternative descriptor to access elements with filtering invalid elements (e.g. textnodes)\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'childTags')) {\n    Object.defineProperty(ElementPrototype, 'childTags', {\n      enumerable: true,\n      get () {\n        return this.children.filter((node) => {\n          // https://github.com/fb55/domelementtype/blob/master/index.js#L12\n          return node.type === 'tag' || node.type === 'script' || node.type === 'style'\n        })\n      }\n    })\n  }\n\n  if (!Object.getOwnPropertyDescriptor(ElementPrototype, 'attributes')) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/attributes\n    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap\n    Object.defineProperty(ElementPrototype, 'attributes', {\n      enumerable: true,\n      get () {\n        const { attribs } = this\n        const attributesNames = Object.keys(attribs)\n        const NamedNodeMap = attributesNames.reduce((attributes, attributeName, index) => {\n          attributes[index] = {\n            name: attributeName,\n            value: attribs[attributeName]\n          }\n          return attributes\n        }, { })\n        Object.defineProperty(NamedNodeMap, 'length', {\n          enumerable: false,\n          configurable: false,\n          value: attributesNames.length\n        })\n        return NamedNodeMap\n      }\n    })\n  }\n\n  if (!ElementPrototype.getAttribute) {\n    // https://docs.webplatform.org/wiki/dom/Element/getAttribute\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttribute\n    ElementPrototype.getAttribute = function (name) {\n      return this.attribs[name] || null\n    }\n  }\n\n  if (!ElementPrototype.getElementsByTagName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByTagName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByTagName\n    ElementPrototype.getElementsByTagName = function (tagName) {\n      const HTMLCollection = []\n      traverseDescendants(this.childTags, (descendant) => {\n        if (descendant.name === tagName || tagName === '*') {\n          HTMLCollection.push(descendant)\n        }\n      })\n      return HTMLCollection\n    }\n  }\n\n  if (!ElementPrototype.getElementsByClassName) {\n    // https://docs.webplatform.org/wiki/dom/Document/getElementsByClassName\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getElementsByClassName\n    ElementPrototype.getElementsByClassName = function (className) {\n      const names = className.trim().replace(/\\s+/g, ' ').split(' ')\n      const HTMLCollection = []\n      traverseDescendants([this], (descendant) => {\n        const descendantClassName = descendant.attribs.class\n        if (descendantClassName && names.every((name) => descendantClassName.indexOf(name) > -1)) {\n          HTMLCollection.push(descendant)\n        }\n      })\n      return HTMLCollection\n    }\n  }\n\n  if (!ElementPrototype.querySelectorAll) {\n    // https://docs.webplatform.org/wiki/css/selectors_api/querySelectorAll\n    // https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll\n    ElementPrototype.querySelectorAll = function (selectors) {\n      selectors = selectors.replace(/(>)(\\S)/g, '$1 $2').trim() // add space for '>' selector\n\n      // using right to left execution => https://github.com/fb55/css-select#how-does-it-work\n      const instructions = getInstructions(selectors)\n      const discover = instructions.shift()\n\n      const total = instructions.length\n      return discover(this).filter((node) => {\n        var step = 0\n        while (step < total) {\n          node = instructions[step](node, this)\n          if (!node) { // hierarchy doesn't match\n            return false\n          }\n          step += 1\n        }\n        return true\n      })\n    }\n  }\n\n  if (!ElementPrototype.contains) {\n    // https://developer.mozilla.org/en-US/docs/Web/API/Node/contains\n    ElementPrototype.contains = function (element) {\n      var inclusive = false\n      traverseDescendants([this], (descendant, done) => {\n        if (descendant === element) {\n          inclusive = true\n          done()\n        }\n      })\n      return inclusive\n    }\n  }\n\n  return true\n}\n\n/**\n * Retrieve transformation steps\n *\n * @param  {Array.<string>}   selectors - [description]\n * @return {Array.<Function>}           - [description]\n */\nfunction getInstructions (selectors) {\n  return selectors.split(' ').reverse().map((selector, step) => {\n    const discover = step === 0\n    const [type, pseudo] = selector.split(':')\n\n    var validate = null\n    var instruction = null\n\n    switch (true) {\n\n      // child: '>'\n      case />/.test(type):\n        instruction = function checkParent (node) {\n          return (validate) => validate(node.parent) && node.parent\n        }\n        break\n\n      // class: '.'\n      case /^\\./.test(type):\n        const names = type.substr(1).split('.')\n        validate = (node) => {\n          const nodeClassName = node.attribs.class\n          return nodeClassName && names.every((name) => nodeClassName.indexOf(name) > -1)\n        }\n        instruction = function checkClass (node, root) {\n          if (discover) {\n            return node.getElementsByClassName(names.join(' '))\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // attribute: '[key=\"value\"]'\n      case /^\\[/.test(type):\n        const [attributeKey, attributeValue] = type.replace(/\\[|\\]|\"/g, '').split('=')\n        validate = (node) => {\n          const hasAttribute = Object.keys(node.attribs).indexOf(attributeKey) > -1\n          if (hasAttribute) { // regard optional attributeValue\n            if (!attributeValue || (node.attribs[attributeKey] === attributeValue)) {\n              return true\n            }\n          }\n          return false\n        }\n        instruction = function checkAttribute (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // id: '#'\n      case /^#/.test(type):\n        const id = type.substr(1)\n        validate = (node) => {\n          return node.attribs.id === id\n        }\n        instruction = function checkId (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant, done) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n                done()\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // universal: '*'\n      case /\\*/.test(type):\n        validate = (node) => true\n        instruction = function checkUniversal (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => NodeList.push(descendant))\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n        break\n\n      // tag: '...'\n      default:\n        validate = (node) => {\n          return node.name === type\n        }\n        instruction = function checkTag (node, root) {\n          if (discover) {\n            const NodeList = []\n            traverseDescendants([node], (descendant) => {\n              if (validate(descendant)) {\n                NodeList.push(descendant)\n              }\n            })\n            return NodeList\n          }\n          return (typeof node === 'function') ? node(validate) : getAncestor(node, root, validate)\n        }\n    }\n\n    if (!pseudo) {\n      return instruction\n    }\n\n    const rule = pseudo.match(/-(child|type)\\((\\d+)\\)$/)\n    const kind = rule[1]\n    const index = parseInt(rule[2], 10) - 1\n\n    const validatePseudo = (node) => {\n      if (node) {\n        var compareSet = node.parent.childTags\n        if (kind === 'type') {\n          compareSet = compareSet.filter(validate)\n        }\n        const nodeIndex = compareSet.findIndex((child) => child === node)\n        if (nodeIndex === index) {\n          return true\n        }\n      }\n      return false\n    }\n\n    return function enhanceInstruction (node) {\n      const match = instruction(node)\n      if (discover) {\n        return match.reduce((NodeList, matchedNode) => {\n          if (validatePseudo(matchedNode)) {\n            NodeList.push(matchedNode)\n          }\n          return NodeList\n        }, [])\n      }\n      return validatePseudo(match) && match\n    }\n  })\n}\n\n/**\n * Walking recursive to invoke callbacks\n *\n * @param {Array.<HTMLElement>} nodes   - [description]\n * @param {Function}            handler - [description]\n */\nfunction traverseDescendants (nodes, handler) {\n  nodes.forEach((node) => {\n    var progress = true\n    handler(node, () => progress = false)\n    if (node.childTags && progress) {\n      traverseDescendants(node.childTags, handler)\n    }\n  })\n}\n\n/**\n * Bubble up from bottom to top\n *\n * @param  {HTMLELement} node     - [description]\n * @param  {HTMLELement} root     - [description]\n * @param  {Function}    validate - [description]\n * @return {HTMLELement}          - [description]\n */\nfunction getAncestor (node, root, validate) {\n  while (node.parent) {\n    node = node.parent\n    if (validate(node)) {\n      return node\n    }\n    if (node === root) {\n      break\n    }\n  }\n  return null\n}\n","/**\n * # Utilities\n *\n * Convenience helpers.\n */\n\n/**\n * Create an array with the DOM nodes of the list\n *\n * @param  {NodeList}             nodes - [description]\n * @return {Array.<HTMLElement>}        - [description]\n */\nexport function convertNodeList (nodes) {\n  const { length } = nodes\n  const arr = new Array(length)\n  for (var i = 0; i < length; i++) {\n    arr[i] = nodes[i]\n  }\n  return arr\n}\n\n/**\n * Escape special characters and line breaks as a simplified version of 'CSS.escape()'\n *\n * Description of valid characters: https://mathiasbynens.be/notes/css-escapes\n *\n * @param  {String?} value - [description]\n * @return {String}        - [description]\n */\nexport function escapeValue (value) {\n  return value && value.replace(/['\"`\\\\/:\\?&!#$%^()[\\]{|}*+;,.<=>@~]/g, '\\\\$&')\n                       .replace(/\\n/g, '\\A')\n}\n","/**\n * # Match\n *\n * Retrieve selector for a node.\n */\n\nimport { escapeValue } from './utilities'\n\nconst defaultIgnore = {\n  attribute (attributeName) {\n    return [\n      'style',\n      'data-reactid',\n      'data-react-checksum'\n    ].indexOf(attributeName) > -1\n  }\n}\n\n/**\n * Get the path of the element\n *\n * @param  {HTMLElement} node    - [description]\n * @param  {Object}      options - [description]\n * @return {string}              - [description]\n */\nexport default function match (node, options) {\n\n  const {\n    root = document,\n    skip = null,\n    priority = ['id', 'class', 'href', 'src'],\n    ignore = {}\n  } = options\n\n  const path = []\n  var element = node\n  var length = path.length\n  var ignoreClass = false\n\n  const skipCompare = skip && (Array.isArray(skip) ? skip : [skip]).map((entry) => {\n    if (typeof entry !== 'function') {\n      return (element) => element === entry\n    }\n    return entry\n  })\n\n  const skipChecks = (element) => {\n    return skip && skipCompare.some((compare) => compare(element))\n  }\n\n  Object.keys(ignore).forEach((type) => {\n    if (type === 'class') {\n      ignoreClass = true\n    }\n    var predicate = ignore[type]\n    if (typeof predicate === 'function') return\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString()\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp(escapeValue(predicate).replace(/\\\\/g, '\\\\\\\\'))\n    }\n    if (typeof predicate === 'boolean') {\n      predicate = predicate ? /(?:)/ : /.^/\n    }\n    // check class-/attributename for regex\n    ignore[type] = (name, value) => predicate.test(value)\n  })\n\n  if (ignoreClass) {\n    const ignoreAttribute = ignore.attribute\n    ignore.attribute = (name, value, defaultPredicate) => {\n      return ignore.class(value) || ignoreAttribute && ignoreAttribute(name, value, defaultPredicate)\n    }\n  }\n\n  while (element !== root) {\n    if (skipChecks(element) !== true) {\n      // ~ global\n      if (checkAttributes(priority, element, ignore, path, root)) break\n      if (checkTag(element, ignore, path, root)) break\n\n      // ~ local\n      checkAttributes(priority, element, ignore, path)\n      if (path.length === length) {\n        checkTag(element, ignore, path)\n      }\n\n      // define only one part each iteration\n      if (path.length === length) {\n        checkChilds(priority, element, ignore, path)\n      }\n    }\n\n    element = element.parentNode\n    length = path.length\n  }\n\n  if (element === root) {\n    const pattern = findPattern(priority, element, ignore)\n    path.unshift(pattern)\n  }\n\n  return path.join(' ')\n}\n\n/**\n * Extend path with attribute identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @param  {HTMLElement}    parent   - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkAttributes (priority, element, ignore, path, parent = element.parentNode) {\n  const pattern = findAttributesPattern(priority, element, ignore)\n  if (pattern) {\n    const matches = parent.querySelectorAll(pattern)\n    if (matches.length === 1) {\n      path.unshift(pattern)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Lookup attribute identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @return {string?}                 - [description]\n */\nfunction findAttributesPattern (priority, element, ignore) {\n  const attributes = element.attributes\n  const sortedKeys = Object.keys(attributes).sort((curr, next) => {\n    const currPos = priority.indexOf(attributes[curr].name)\n    const nextPos = priority.indexOf(attributes[next].name)\n    if (nextPos === -1) {\n      if (currPos === -1) {\n        return 0\n      }\n      return -1\n    }\n    return currPos - nextPos\n  })\n\n  for (var i = 0, l = sortedKeys.length; i < l; i++) {\n    const key = sortedKeys[i]\n    const attribute = attributes[key]\n    const attributeName = attribute.name\n    const attributeValue = escapeValue(attribute.value)\n\n    const currentIgnore = ignore[attributeName] || ignore.attribute\n    const currentDefaultIgnore = defaultIgnore[attributeName] || defaultIgnore.attribute\n    if (checkIgnore(currentIgnore, attributeName, attributeValue, currentDefaultIgnore)) {\n      continue\n    }\n\n    var pattern = `[${attributeName}=\"${attributeValue}\"]`\n\n    if ((/\\b\\d/).test(attributeValue) === false) {\n      if (attributeName === 'id') {\n        pattern = `#${attributeValue}`\n      }\n\n      if (attributeName === 'class') {\n        const className = attributeValue.trim().replace(/\\s+/g, '.')\n        pattern = `.${className}`\n      }\n    }\n\n    return pattern\n  }\n  return null\n}\n\n/**\n * Extend path with tag identifier\n *\n * @param  {HTMLElement}    element - [description]\n * @param  {Object}         ignore  - [description]\n * @param  {Array.<string>} path    - [description]\n * @param  {HTMLElement}    parent  - [description]\n * @return {boolean}                - [description]\n */\nfunction checkTag (element, ignore, path, parent = element.parentNode) {\n  const pattern = findTagPattern(element, ignore)\n  if (pattern) {\n    const matches = parent.getElementsByTagName(pattern)\n    if (matches.length === 1) {\n      path.unshift(pattern)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Lookup tag identifier\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      ignore  - [description]\n * @return {boolean}             - [description]\n */\nfunction findTagPattern (element, ignore) {\n  const tagName = element.tagName.toLowerCase()\n  if (checkIgnore(ignore.tag, null, tagName)) {\n    return null\n  }\n  return tagName\n}\n\n/**\n * Extend path with specific child identifier\n *\n * NOTE: 'childTags' is a custom property to use as a view filter for tags using 'adapter.js'\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @param  {Array.<string>} path     - [description]\n * @return {boolean}                 - [description]\n */\nfunction checkChilds (priority, element, ignore, path) {\n  const parent = element.parentNode\n  const children = parent.childTags || parent.children\n  for (var i = 0, l = children.length; i < l; i++) {\n    const child = children[i]\n    if (child === element) {\n      const childPattern = findPattern(priority, child, ignore)\n      if (!childPattern) {\n        return console.warn(`\n          Element couldn\\'t be matched through strict ignore pattern!\n        `, child, ignore, childPattern)\n      }\n      const pattern = `> ${childPattern}:nth-child(${i+1})`\n      path.unshift(pattern)\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Lookup identifier\n *\n * @param  {Array.<string>} priority - [description]\n * @param  {HTMLElement}    element  - [description]\n * @param  {Object}         ignore   - [description]\n * @return {string}                  - [description]\n */\nfunction findPattern (priority, element, ignore) {\n  var pattern = findAttributesPattern(priority, element, ignore)\n  if (!pattern) {\n    pattern = findTagPattern(element, ignore)\n  }\n  return pattern\n}\n\n/**\n * Validate with custom and default functions\n *\n * @param  {Function} predicate        - [description]\n * @param  {string?}  name             - [description]\n * @param  {string}   value            - [description]\n * @param  {Function} defaultPredicate - [description]\n * @return {boolean}                   - [description]\n */\nfunction checkIgnore (predicate, name, value, defaultPredicate) {\n  if (!value) {\n    return true\n  }\n  const check = predicate || defaultPredicate\n  if (!check) {\n    return false\n  }\n  return check(name, value, defaultPredicate)\n}\n","/**\n * # Optimize\n *\n * 1.) Improve efficiency through shorter selectors by removing redundancy\n * 2.) Improve robustness through selector transformation\n */\n\nimport adapt from './adapt'\nimport { convertNodeList } from './utilities'\n\n/**\n * Apply different optimization techniques\n *\n * @param  {string}                          selector - [description]\n * @param  {HTMLElement|Array.<HTMLElement>} element  - [description]\n * @param  {Object}                          options  - [description]\n * @return {string}                                   - [description]\n */\nexport default function optimize (selector, elements, options = {}) {\n\n  // convert single entry and NodeList\n  if (!Array.isArray(elements)) {\n    elements = !elements.length ? [elements] : convertNodeList(elements)\n  }\n\n  if (!elements.length || elements.some((element) => element.nodeType !== 1)) {\n    throw new Error(`Invalid input - to compare HTMLElements its necessary to provide a reference of the selected node(s)! (missing \"elements\")`)\n  }\n\n  const globalModified = adapt(elements[0], options)\n\n  // chunk parts outside of quotes (http://stackoverflow.com/a/25663729)\n  var path = selector.replace(/> /g, '>').split(/\\s+(?=(?:(?:[^\"]*\"){2})*[^\"]*$)/)\n\n  if (path.length < 2) {\n    return optimizePart('', selector, '', elements)\n  }\n\n  const shortened = [path.pop()]\n  while (path.length > 1)  {\n    const current = path.pop()\n    const prePart = path.join(' ')\n    const postPart = shortened.join(' ')\n\n    const pattern = `${prePart} ${postPart}`\n    const matches = document.querySelectorAll(pattern)\n    if (matches.length !== elements.length) {\n      shortened.unshift(optimizePart(prePart, current, postPart, elements))\n    }\n  }\n  shortened.unshift(path[0])\n  path = shortened\n\n  // optimize start + end\n  path[0] = optimizePart('', path[0], path.slice(1).join(' '), elements)\n  path[path.length-1] = optimizePart(path.slice(0, -1).join(' '), path[path.length-1], '', elements)\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return path.join(' ').replace(/>/g, '> ').trim()\n}\n\n/**\n * Improve a chunk of the selector\n *\n * @param  {string}              prePart  - [description]\n * @param  {string}              current  - [description]\n * @param  {string}              postPart - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {string}                       - [description]\n */\nfunction optimizePart (prePart, current, postPart, elements) {\n  if (prePart.length) prePart = `${prePart} `\n  if (postPart.length) postPart = ` ${postPart}`\n\n  // robustness: attribute without value (generalization)\n  if (/\\[*\\]/.test(current)) {\n    const key = current.replace(/=.*$/, ']')\n    var pattern = `${prePart}${key}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (compareResults(matches, elements)) {\n      current = key\n    } else {\n      // robustness: replace specific key-value with base tag (heuristic)\n      const references = document.querySelectorAll(`${prePart}${key}`)\n      for (var i = 0, l = references.length; i < l; i++) {\n        const reference = references[i]\n        if (elements.some((element) => reference.contains(element))) {\n          const description = reference.tagName.toLowerCase()\n          var pattern = `${prePart}${description}${postPart}`\n          var matches = document.querySelectorAll(pattern)\n          if (compareResults(matches, elements)) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  // robustness: descendant instead child (heuristic)\n  if (/>/.test(current)) {\n    const descendant = current.replace(/>/, '')\n    var pattern = `${prePart}${descendant}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (compareResults(matches, elements)) {\n      current = descendant\n    }\n  }\n\n  // robustness: 'nth-of-type' instead 'nth-child' (heuristic)\n  if (/:nth-child/.test(current)) {\n    // TODO: consider complete coverage of 'nth-of-type' replacement\n    const type = current.replace(/nth-child/g, 'nth-of-type')\n    var pattern = `${prePart}${type}${postPart}`\n    var matches = document.querySelectorAll(pattern)\n    if (compareResults(matches, elements)) {\n      current = type\n    }\n  }\n\n  // efficiency: combinations of classname (partial permutations)\n  if (/\\.\\S+\\.\\S+/.test(current)) {\n    var names = current.trim().split('.').slice(1)\n                                         .map((name) => `.${name}`)\n                                         .sort((curr, next) => curr.length - next.length)\n    while (names.length) {\n      const partial = current.replace(names.shift(), '').trim()\n      var pattern = `${prePart}${partial}${postPart}`.trim()\n      if (!pattern.length || pattern.charAt(0) === '>' || pattern.charAt(pattern.length-1) === '>') {\n        break\n      }\n      var matches = document.querySelectorAll(pattern)\n      if (compareResults(matches, elements)) {\n        current = partial\n      }\n    }\n\n    // robustness: degrade complex classname (heuristic)\n    names = current && current.match(/\\./g)\n    if (names && names.length > 2) {\n      const references = document.querySelectorAll(`${prePart}${current}`)\n      for (var i = 0, l = references.length; i < l; i++) {\n        const reference = references[i]\n        if (elements.some((element) => reference.contains(element) )) {\n          // TODO:\n          // - check using attributes + regard excludes\n          const description = reference.tagName.toLowerCase()\n          var pattern = `${prePart}${description}${postPart}`\n          var matches = document.querySelectorAll(pattern)\n          if (compareResults(matches, elements)) {\n            current = description\n          }\n          break\n        }\n      }\n    }\n  }\n\n  return current\n}\n\n/**\n * Evaluate matches with expected elements\n *\n * @param  {Array.<HTMLElement>} matches  - [description]\n * @param  {Array.<HTMLElement>} elements - [description]\n * @return {Boolean}                      - [description]\n */\nfunction compareResults (matches, elements) {\n  const { length } = matches\n  return length === elements.length && elements.every((element) => {\n    for (var i = 0; i < length; i++) {\n      if (matches[i] === element) {\n        return true\n      }\n    }\n    return false\n  })\n}\n","/**\n * # Common\n *\n * Process collections for similarities.\n */\n\nimport { escapeValue } from './utilities'\n\n/**\n * Find the last common ancestor of elements\n *\n * @param  {Array.<HTMLElements>} elements - [description]\n * @return {HTMLElement}                   - [description]\n */\nexport function getCommonAncestor (elements, options = {}) {\n\n  const {\n    root = document\n  } = options\n\n  const ancestors = []\n\n  elements.forEach((element, index) => {\n    const parents = []\n    while (element !== root) {\n      element = element.parentNode\n      parents.unshift(element)\n    }\n    ancestors[index] = parents\n  })\n\n  ancestors.sort((curr, next) => curr.length - next.length)\n\n  const shallowAncestor = ancestors.shift()\n\n  var ancestor = null\n\n  for (var i = 0, l = shallowAncestor.length; i < l; i++) {\n    const parent = shallowAncestor[i]\n    const missing = ancestors.some((otherParents) => {\n      return !otherParents.some((otherParent) => otherParent === parent)\n    })\n\n    if (missing) {\n      // TODO: find similar sub-parents, not the top root, e.g. sharing a class selector\n      break\n    }\n\n    ancestor = parent\n  }\n\n  return ancestor\n}\n\n/**\n * Get a set of common properties of elements\n *\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {Object}              options  - [description]\n * @return {Object}                       - [description]\n */\nexport function getCommonProperties (elements, options = {}) {\n\n  const {\n    ignore = {}\n  } = options\n\n  // Normalize ignore predicates (same logic as match.js)\n  const normalizedIgnore = {}\n  Object.keys(ignore).forEach((type) => {\n    var predicate = ignore[type]\n    if (typeof predicate === 'function') {\n      normalizedIgnore[type] = predicate\n      return\n    }\n    if (typeof predicate === 'number') {\n      predicate = predicate.toString()\n    }\n    if (typeof predicate === 'string') {\n      predicate = new RegExp(escapeValue(predicate).replace(/\\\\/g, '\\\\\\\\'))\n    }\n    if (typeof predicate === 'boolean') {\n      predicate = predicate ? /(?:)/ : /.^/\n    }\n    // check class-/attributename for regex\n    normalizedIgnore[type] = (name, value) => predicate.test(value)\n  })\n\n  const checkIgnore = (type, name, value) => {\n    const predicate = normalizedIgnore[type]\n    if (!predicate) return false\n    return predicate(name, value)\n  }\n\n  const commonProperties = {\n    classes: [],\n    attributes: {},\n    tag: null\n  }\n\n  elements.forEach((element) => {\n\n    var {\n      classes: commonClasses,\n      attributes: commonAttributes,\n      tag: commonTag\n    } = commonProperties\n\n    // ~ classes\n    if (commonClasses !== undefined) {\n      var classes = element.getAttribute('class')\n      if (classes) {\n        classes = classes.trim().split(' ').filter((className) => {\n          // Filter out ignored classes\n          return !checkIgnore('class', className, className)\n        })\n        if (!classes.length) {\n          delete commonProperties.classes\n        } else if (!commonClasses.length) {\n          commonProperties.classes = classes\n        } else {\n          commonClasses = commonClasses.filter((entry) => classes.some((name) => name === entry))\n          if (commonClasses.length) {\n            commonProperties.classes = commonClasses\n          } else {\n            delete commonProperties.classes\n          }\n        }\n      } else {\n        // TODO: restructure removal as 2x set / 2x delete, instead of modify always replacing with new collection\n        delete commonProperties.classes\n      }\n    }\n\n    // ~ attributes\n    if (commonAttributes !== undefined) {\n      const elementAttributes = element.attributes\n      const attributes = Object.keys(elementAttributes).reduce((attributes, key) => {\n        const attribute = elementAttributes[key]\n        const attributeName = attribute.name\n        const attributeValue = attribute.value\n        // NOTE: workaround detection for non-standard phantomjs NamedNodeMap behaviour\n        // (issue: https://github.com/ariya/phantomjs/issues/14634)\n        if (attribute && attributeName !== 'class') {\n          // Filter out ignored attributes\n          if (!checkIgnore(attributeName, attributeName, attributeValue) &&\n              !checkIgnore('attribute', attributeName, attributeValue)) {\n            attributes[attributeName] = attributeValue\n          }\n        }\n        return attributes\n      }, {})\n\n      const attributesNames = Object.keys(attributes)\n      const commonAttributesNames = Object.keys(commonAttributes)\n\n      if (attributesNames.length) {\n        if (!commonAttributesNames.length) {\n          commonProperties.attributes = attributes\n        } else {\n          commonAttributes = commonAttributesNames.reduce((nextCommonAttributes, name) => {\n            const value = commonAttributes[name]\n            if (value === attributes[name]) {\n              nextCommonAttributes[name] = value\n            }\n            return nextCommonAttributes\n          }, {})\n          if (Object.keys(commonAttributes).length) {\n            commonProperties.attributes = commonAttributes\n          } else {\n            delete commonProperties.attributes\n          }\n        }\n      } else {\n        delete commonProperties.attributes\n      }\n    }\n\n    // ~ tag\n    if (commonTag !== undefined) {\n      const tag = element.tagName.toLowerCase()\n      // Filter out ignored tags\n      if (checkIgnore('tag', null, tag)) {\n        delete commonProperties.tag\n      } else if (!commonTag) {\n        commonProperties.tag = tag\n      } else if (tag !== commonTag) {\n        delete commonProperties.tag\n      }\n    }\n  })\n\n  return commonProperties\n}\n","/**\n * # Select\n *\n * Construct a unique CSS query selector to access the selected DOM element(s).\n * For longevity it applies different matching and optimization strategies.\n */\n\nimport adapt from './adapt'\nimport match from './match'\nimport optimize from './optimize'\nimport { convertNodeList } from './utilities'\nimport { getCommonAncestor, getCommonProperties } from './common'\n\n/**\n * Get a selector for the provided element\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      options - [description]\n * @return {string}              - [description]\n */\nexport function getSingleSelector (element, options = {}) {\n\n  if (element.nodeType === 3) {\n    element = element.parentNode\n  }\n\n  if (element.nodeType !== 1) {\n    throw new Error(`Invalid input - only HTMLElements or representations of them are supported! (not \"${typeof element}\")`)\n  }\n\n  const globalModified = adapt(element, options)\n\n  const selector = match(element, options)\n  const optimized = optimize(selector, element, options)\n\n  // debug\n  // console.log(`\n  //   selector:  ${selector}\n  //   optimized: ${optimized}\n  // `)\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return optimized\n}\n\n/**\n * Get a selector to match multiple descendants from an ancestor\n *\n * @param  {Array.<HTMLElement>|NodeList} elements - [description]\n * @param  {Object}                       options  - [description]\n * @return {string}                                - [description]\n */\nexport function getMultiSelector (elements, options = {}) {\n\n  if (!Array.isArray(elements)) {\n    elements = convertNodeList(elements)\n  }\n\n  if (elements.some((element) => element.nodeType !== 1)) {\n    throw new Error(`Invalid input - only an Array of HTMLElements or representations of them is supported!`)\n  }\n\n  const globalModified = adapt(elements[0], options)\n\n  const ancestor = getCommonAncestor(elements, options)\n  const ancestorSelector = getSingleSelector(ancestor, options)\n\n  // TODO: consider usage of multiple selectors + parent-child relation + check for part redundancy\n  const commonSelectors = getCommonSelectors(elements, options)\n  const descendantSelector = commonSelectors[0]\n\n  const selector = optimize(`${ancestorSelector} ${descendantSelector}`, elements, options)\n  const selectorMatches = convertNodeList(document.querySelectorAll(selector))\n\n  if (!elements.every((element) => selectorMatches.some((entry) => entry === element) )) {\n    // Cluster elements by selector pattern and try to generate combined selector\n    const clusters = clusterElementsBySelector(elements, options)\n\n    // If only one cluster, cannot improve - fall back to warning\n    if (clusters.size <= 1) {\n      if (globalModified) {\n        delete global.document\n      }\n      console.warn(`\n        The selected elements can\\'t be efficiently mapped.\n        Its probably best to use multiple single selectors instead!\n      `, elements)\n      return undefined\n    }\n\n    // Generate selector for each cluster\n    const clusterSelectors = []\n    for (const [pattern, clusterElements] of clusters) {\n      const clusterSelector = `${ancestorSelector} ${pattern}`\n      const optimizedSelector = optimize(clusterSelector, clusterElements, options)\n\n      // Validate the selector matches all elements in the cluster\n      const matches = convertNodeList(document.querySelectorAll(optimizedSelector))\n      const allMatch = clusterElements.every((el) => matches.some((m) => m === el))\n\n      if (allMatch) {\n        clusterSelectors.push(optimizedSelector)\n      } else {\n        // Validation failed - fall back to warning\n        if (globalModified) {\n          delete global.document\n        }\n        console.warn(`\n          The selected elements can\\'t be efficiently mapped.\n          Its probably best to use multiple single selectors instead!\n        `, elements)\n        return undefined\n      }\n    }\n\n    if (globalModified) {\n      delete global.document\n    }\n\n    // Return comma-separated selectors\n    return clusterSelectors.join(', ')\n  }\n\n  if (globalModified) {\n    delete global.document\n  }\n\n  return selector\n}\n\n/**\n * Build a selector string from common properties\n *\n * @param  {Object} properties - { classes, attributes, tag }\n * @return {string}            - selector string\n */\nfunction buildSelectorFromProperties ({ classes, attributes, tag }) {\n  const selectorPath = []\n\n  if (tag) {\n    selectorPath.push(tag)\n  }\n\n  if (classes && classes.length) {\n    const classSelector = classes.map((name) => `.${name}`).join('')\n    selectorPath.push(classSelector)\n  }\n\n  if (attributes && Object.keys(attributes).length) {\n    const attributeSelector = Object.keys(attributes).reduce((parts, name) => {\n      parts.push(`[${name}=\"${attributes[name]}\"]`)\n      return parts\n    }, []).join('')\n    selectorPath.push(attributeSelector)\n  }\n\n  return selectorPath.join('')\n}\n\n/**\n * Get selectors to describe a set of elements\n *\n * @param  {Array.<HTMLElements>} elements - [description]\n * @param  {Object}               options  - [description]\n * @return {string}                        - [description]\n */\nfunction getCommonSelectors (elements, options = {}) {\n\n  const properties = getCommonProperties(elements, options)\n\n  if (properties.classes || properties.attributes || properties.tag) {\n    // TODO: check for parent-child relation\n  }\n\n  return [\n    buildSelectorFromProperties(properties)\n  ]\n}\n\n\n/**\n * Get selector pattern for a single element\n *\n * @param  {HTMLElement} element - [description]\n * @param  {Object}      options - [description]\n * @return {string}              - selector pattern\n */\nfunction getElementSelectorPattern (element, options = {}) {\n  const properties = getCommonProperties([element], options)\n  return buildSelectorFromProperties(properties)\n}\n\n/**\n * Cluster elements by their selector pattern\n *\n * @param  {Array.<HTMLElement>} elements - [description]\n * @param  {Object}              options  - [description]\n * @return {Map}                          - Map of pattern -> elements\n */\nfunction clusterElementsBySelector (elements, options = {}) {\n  const clusters = new Map()\n\n  elements.forEach((element) => {\n    const pattern = getElementSelectorPattern(element, options)\n\n    if (!clusters.has(pattern)) {\n      clusters.set(pattern, [])\n    }\n    clusters.get(pattern).push(element)\n  })\n\n  return clusters\n}\n\n/**\n * Choose action depending on the input (multiple/single)\n *\n * NOTE: extended detection is used for special cases like the <select> element with <options>\n *\n * @param  {HTMLElement|NodeList|Array.<HTMLElement>} input   - [description]\n * @param  {Object}                                   options - [description]\n * @return {string}                                           - [description]\n */\nexport default function getQuerySelector (input, options = {}) {\n  if (input.length && !input.name) {\n    return getMultiSelector(input, options)\n  }\n  return getSingleSelector(input, options)\n}\n","/**\n * # optimal-select\n *\n * ESModule entry point for esbuild\n */\n\nimport select, { getSingleSelector, getMultiSelector } from './select.js'\nimport optimize from './optimize.js'\nimport * as common from './common.js'\n\nexport { select, getSingleSelector, getMultiSelector, optimize, common }\nexport default select\n"],"names":["root","factory","exports","module","define","amd","this","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","g","globalThis","Function","e","window","obj","prop","prototype","hasOwnProperty","call","adapt","element","options","global","document","context","parent","ElementPrototype","getPrototypeOf","getOwnPropertyDescriptor","children","filter","node","type","attribs","attributesNames","keys","NamedNodeMap","reduce","attributes","attributeName","index","name","value","configurable","length","getAttribute","getElementsByTagName","tagName","HTMLCollection","traverseDescendants","childTags","descendant","push","getElementsByClassName","className","names","trim","replace","split","descendantClassName","every","indexOf","querySelectorAll","selectors","_this","instructions","reverse","map","selector","step","discover","_selector$split2","_slicedToArray","pseudo","validate","instruction","test","substr","nodeClassName","join","getAncestor","_type$replace$split2","attributeKey","attributeValue","NodeList","id","done","rule","match","kind","parseInt","validatePseudo","compareSet","findIndex","child","matchedNode","getInstructions","shift","total","contains","inclusive","nodes","handler","forEach","progress","convertNodeList","arr","Array","i","escapeValue","defaultIgnore","attribute","checkAttributes","priority","ignore","path","arguments","undefined","parentNode","pattern","findAttributesPattern","unshift","sortedKeys","sort","curr","next","currPos","nextPos","l","checkIgnore","concat","checkTag","findTagPattern","toLowerCase","tag","checkChilds","childPattern","findPattern","console","warn","predicate","defaultPredicate","check","optimize","elements","isArray","some","nodeType","Error","globalModified","optimizePart","shortened","pop","current","prePart","postPart","slice","compareResults","references","_loop","reference","description","partial","charAt","_loop2","matches","getCommonProperties","_options$ignore","normalizedIgnore","toString","RegExp","commonProperties","classes","commonClasses","commonAttributes","commonTag","entry","elementAttributes","commonAttributesNames","nextCommonAttributes","getSingleSelector","_typeof","_options$root","_options$skip","skip","_options$priority","ignoreClass","skipCompare","skipChecks","compare","ignoreAttribute","optimized","getMultiSelector","ancestor","ancestors","parents","shallowAncestor","otherParents","otherParent","getCommonAncestor","ancestorSelector","commonSelectors","properties","buildSelectorFromProperties","getCommonSelectors","descendantSelector","selectorMatches","clusters","Map","getElementSelectorPattern","has","set","clusterElementsBySelector","size","_step","clusterSelectors","_iterator","_createForOfIteratorHelper","_ret","_step$value","clusterElements","optimizedSelector","el","m","v","s","n","err","f","_ref","selectorPath","classSelector","attributeSelector","parts","input"],"ignoreList":[],"sourceRoot":""}